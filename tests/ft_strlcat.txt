# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    ft_strlcat.txt                                     :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jgermany <nyaritakunai@outlook.com>        +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2022/12/17 01:04:17 by jgermany          #+#    #+#              #
#    Updated: 2022/12/17 01:04:19 by jgermany         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

Libft - ft_strlcat 游릭游댮

Evil tests made with 游땓游땓游땓 passion

Context : The strlcpy() and strlcat() functions copy and concatenate strings 
respectively. 

Unlike those functions, strlcpy() and strlcat() take the full
size of the buffer (not just the length) and guarantee to NUL-terminate the
result (as long as size is larger than 0 or, in the case of strlcat(), as 
long as there is at least one byte free in dst). Note that a byte for the NUL
should be included in size.

Also note that strlcpy() and strlcat() only
operate on true ''C'' strings. This means that for strlcpy() src must
be NUL-terminated and for strlcat() both src and dst must be NUL-terminated. 
The strlcat() function appends the NUL-terminated string src to the end of dst.
It will append at most size - strlen(dst) - 1 bytes, NUL-terminating the result.

The strlcpy() and strlcat() functions return the total length of the string 
they tried to create. For strlcpy() that means the length of src. 
For strlcat() that means the initial length of dst plus the length of src.

Test material
	- strs ex : "hello" " world"
	- Original strlcat (#include <bsd/string.h>) for comparison,
	compile with -lbsd at the end

Prototype
	size_t	strlcat(char *dst, const char *src, size_t size);


[游릭] Happy path :)
	"Hello" " world" "12"
		-> 11 "Hello world"


[游릭] Oops wrong size, forgot \0 (full size buffer)
	"Hello" " world" "11"
		-> 11 "Hello worl"

[游릭] Copy nothing
	"Hello" " world" "5"
		-> 11 "Hello"

[游릭] I SAID NOTHING !!!
	"Hello" " world" "0"
		-> 6 "Hello"

[游릭] Ok... A bit more
	"Hello" " world" "1"
		-> 7 "Hello"

[游릭]More, more!!
	"Hello" " world" "3"
		-> 9 "Hello"

[游릭] MOTTO HOSHII!!
	"Hello" " world" "99"
		-> 11 "Hello world"

[游릭] Why so negative!! (underflow converted to 4294967295)
	"Hello" " world" "-1"
		-> 11 "Hello world"


[游릭] Empty dest, size too small
	"" "world" "3"
		-> 5 "wo"

[游릭] Empty dest, size still too small (\0 for null)
	"" "world" "5"
		-> 5 "worl"

[游릭] Empty dest, size just enough
	"" "world" "6"
		-> 5 "world"

[游릭] Empty dest, too much size
	"" "world" "18"
		-> 5 "world"


[游릭] Empty src, but why doing that ???
	"Hello" "" "0"
		-> 0 "Hello"

[游릭] Empty src, a target size, but why doing that ???
	"Hello" "" "12"
		-> 5 "Hello"


[游릭] Empty dest. Empty src. Does size matter ?
	"" "" "10"
		-> 0 ""

[游릭] Uh ?
	"" "" "0"
		-> 0 ""

[游릭] Uh ?????
	"" "" "5"
		-> 0 ""


[游릭] Special chars (should) do nothing here
	"\n" "\n" "3"
		-> 4 "\n" (remember - 2 + null)

[游릭] Special chars (should) do nothing here too
	"\n" "\n" "4"
			-> 4 "\n\"

[游릭] Special chars (should) do nothing here too too
	"\n" "\0" "5"
			-> 4 "\n\0"

[游릭] Special chars (should) do nothing here 4
	"\x0" "\xa" "4"
			-> 6 "\x0"


[游댮] src or dest not nulled
	No protection against these cases in the new version learned from
	newbsd... Will deepthought consider this as a problem?