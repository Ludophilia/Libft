# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    ft_memmove.txt                                     :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jgermany <nyaritakunai@outlook.com>        +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2022/11/25 11:26:54 by jgermany          #+#    #+#              #
#    Updated: 2022/12/15 13:14:13 by jgermany         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

Libft - ft_memmove 游릭游댮

Evil tests made with 游땓游땓游땓 passion

Context : The memmove() function copies n bytes from memory area src to
       memory area dest.  The memory areas may overlap: copying takes
       place as though the bytes in src are first copied into a
       temporary array that does not overlap src or dest, and the bytes
       are then copied from the temporary array to dest.

Test material
	- Array 1 of char of 5 elements or space allocated via malloc
	- Array 2 of char of 5 elements or space allocated via malloc
	- Original memmove (#include <string.h>) for comparison

[游릭] Happy path
	ft_memmove(arr2, arr1, 3)
		-> 3 bytes copied from arr2 to arr1

[游릭] Void pointer well received. Over.
	ft_memmove(arr2, arr1, 3)
		-> arr2 is returned (check pointers with printf, or smth else)

[游릭] Exact size
	ft_memmove(arr2, arr1, 5)
		-> 5 bytes copied from arr2 to arr1

[游릭] No size
	ft_memmove(arr2, arr1, 0)
		-> Nothing changes in arr2

[游릭] Size too long
	ft_memmove(arr2, arr1, 10)
		-> Write as much as needed (+ Undefined behavior - *** stack smashing 
		detected *** : terminated)

[游릭] Invalid memory address
	ft_memmove((void *)0, arr1, 1)
		-> Segfault / Undefined behavior
	ft_memmove(arr2, (void *)0, 1)
		-> Segfault / Undefined behavior
	ft_memmove((void *)0, (void *)0, 1)
		-> Nothing changes

[游릭] Overlapping memory address (case (dest > src) and (dest < src))
	ft_memmove(arr1 + 1, arr1, 3) (dest > src)
		-> Content is copied without problems (1, 2, 3, 4, 5 becomes 
		1, 1, 2, 3, 5)
	ft_memmove(arr1, arr1 + 1, 2) (dest < src)
		-> Content is copied without problems (1, 2, 3, 4, 5 becomes 
		2, 3, 3, 4, 5)
	ft_memmove(arr1, arr1, 3)
		-> Nothing change. And why should we do anything in the first place?
